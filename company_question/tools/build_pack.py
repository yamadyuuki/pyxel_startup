# -*- coding: utf-8 -*-
"""
CSVファイルからクイズパックを生成してpacks/pack_generated.pyに出力します

入力CSVフォーマット (yfinanceのデフォルト):
  Date,Open,High,Low,Close,Adj Close,Volume

使用例:
  uv run python tools/build_pack.py --csv-dir data/raw
  uv run python tools/build_pack.py --csv-files data/raw/5032_T_2022-08-28_to_2025-09-06.csv
  uv run python tools/build_pack.py --csv-dir data/raw --step 3 --scale 10000 --out packs/pack_sample.py \
      --name-map tools/name_map.csv
"""
import argparse
import csv
import glob
import os
import random
from dataclasses import dataclass
from typing import Dict, List, Tuple

# -------- Settings (defaults) --------
DEFAULT_SCALE = 10000  # normalized base value
RNG_SEED = 42          # deterministic choices


@dataclass
class Series:
    ticker: str                # e.g. 5032.T
    name: str                  # e.g. ANYCOLOR Inc.
    span: Tuple[str, str]      # (start_date, end_date)
    prices: List[int]          # normalized ints


def ensure_dir(p: str) -> None:
    os.makedirs(p, exist_ok=True)


def read_name_map(path: str) -> Dict[str, str]:
    """
    ヘッダー付きのCSV: ticker,name
    例:
      5032.T,ANYCOLOR Inc.
      7203.T,Toyota Motor
    """
    mp: Dict[str, str] = {}
    with open(path, "r", encoding="utf-8-sig", newline="") as f:
        r = csv.DictReader(f)
        for row in r:
            t = row.get("ticker", "").strip()
            n = row.get("name", "").strip()
            if t and n:
                mp[t] = n
    return mp


def parse_csv(path: str, step: int, scale: int, name_fallback: str) -> Series:
    """
    yfinance CSVを読み込み、正規化されたSeriesを返します。
    - step: ダウンサンプリングの間隔 (例: 3 => 3行ごと)
    - scale: 基準正規化値 (最初の終値 -> scale)
    """
    # infer ticker from filename: replace '_' back to '.'
    # e.g. data/raw/5032_T_2022-08-28_to_2025-09-06.csv -> 5032.T
    base = os.path.basename(path)
    parts = base.split("_")
    if len(parts) >= 2:
        ticker = f"{parts[0]}.{parts[1]}".replace("..", ".")
    else:
        # フォールバック：拡張子を除いたファイル名などを使う等、適宜対処
        ticker = os.path.splitext(base)[0]

    dates: List[str] = []
    closes: List[float] = []
    with open(path, "r", encoding="utf-8-sig", newline="") as f:
        r = csv.DictReader(f)
        for i, row in enumerate(r):
            # down-sampling
            if step > 1 and (i % step) != 0:
                continue
            d = (row.get("Date") or row.get("Datetime") or "").strip()
            c = row.get("Close")
            if not d or c is None or c == "":
                continue
            try:
                cval = float(c)
            except ValueError:
                continue
            dates.append(d)
            closes.append(cval)

    if not closes:
        raise RuntimeError(f"No close prices in {path}")

    base_close = closes[0]
    if base_close == 0:
        raise RuntimeError(f"First close price is zero in {path}")

    prices_norm = [int(round((v / base_close) * scale)) for v in closes]
    span = (dates[0], dates[-1])

    return Series(
        ticker=ticker,
        name=name_fallback,
        span=span,
        prices=prices_norm,
    )


def to_identifier(s: str) -> str:
    """必要に応じてPythonの変数名として安全な識別子に変換します."""
    out = []
    for ch in s:
        if ch.isalnum():
            out.append(ch)
        elif ch in ('.', '-'):
            out.append('_')
        else:
            out.append('_')
    v = "".join(out)
    if v and v[0].isdigit():
        v = "_" + v
    return v


def build_questions_py(series_list: List[Series],
                       name_map: Dict[str, str],
                       out_path: str) -> None:
    """
    `QUESTIONS`リストを定義するPythonモジュールを英語で出力します。
    選択肢は他の企業名からサンプリングして構築されます。
    """
    ensure_dir(os.path.dirname(out_path))
    random.seed(RNG_SEED)

    # fill names from name_map if present
    all_names = []
    for s in series_list:
        if s.ticker in name_map:
            s.name = name_map[s.ticker]
        elif not s.name or s.name == s.ticker:
            # fallback to ticker if no mapping provided
            s.name = s.ticker
        all_names.append(s.name)

    with open(out_path, "w", encoding="utf-8", newline="\n") as w:
        w.write("# Auto-generated by tools/build_pack.py\n")
        w.write("from core.models import Question\n\n")
        w.write("QUESTIONS = [\n")
        for s in series_list:
            # build 3 distractors
            pool = [n for n in all_names if n != s.name]
            if len(pool) >= 3:
                distractors = random.sample(pool, 3)
            else:
                # not enough pool -> repeat ticker-based fillers
                distractors = (pool + [f"{s.ticker}-A", f"{s.ticker}-B", f"{s.ticker}-C"])[:3]

            # shuffle choices with correct answer
            choices = distractors + [s.name]
            random.shuffle(choices)

            # minimal English blurb placeholder (edit later if needed)
            blurb = f"{s.name} stock price quiz item. The company name is in English."

            # write Question entry
            w.write("    Question(\n")
            w.write(f"        ticker={s.ticker!r},\n")
            w.write(f"        name={s.name!r},\n")
            w.write(f"        span=({s.span[0]!r}, {s.span[1]!r}),\n")
            # split prices lines for readability
            prices_str = ", ".join(str(x) for x in s.prices)
            w.write("        prices=[")
            w.write(prices_str)
            w.write("],\n")
            # choices
            w.write("        choices=[")
            w.write(", ".join(repr(c) for c in choices))
            w.write("],\n")
            w.write(f"        blurb={blurb!r},\n")
            w.write("    ),\n")
        w.write("]\n")

    print(f"[OK] Wrote {out_path} with {len(series_list)} questions.")


def main():
    ap = argparse.ArgumentParser(description="Build Pyxel quiz pack from CSVs.")
    ap.add_argument("--csv-dir", type=str, help="Directory containing CSVs (glob: *.csv)")
    ap.add_argument("--csv-files", nargs="*", help="Explicit CSV files")
    ap.add_argument("--step", type=int, default=3, help="Down-sampling step (default: 3)")
    ap.add_argument("--scale", type=int, default=DEFAULT_SCALE, help="Normalization base (default: 10000)")
    ap.add_argument("--out", type=str, default="packs/pack_generated.py", help="Output pack path")
    ap.add_argument("--name-map", type=str, default="", help="CSV with header: ticker,name (English)")
    args = ap.parse_args()

    csv_paths: List[str] = []
    if args.csv_dir:
        csv_paths.extend(glob.glob(os.path.join(args.csv_dir, "*.csv")))
    if args.csv_files:
        csv_paths.extend(args.csv_files)
    csv_paths = sorted(set(csv_paths))

    if not csv_paths:
        raise SystemExit("No CSV files. Use --csv-dir or --csv-files")

    name_map: Dict[str, str] = {}
    if args.name_map and os.path.exists(args.name_map):
        name_map = read_name_map(args.name_map)

    series_list: List[Series] = []
    for p in csv_paths:
        # fallback company name: use ticker until name_map fills it
        s = parse_csv(p, step=args.step, scale=args.scale, name_fallback="(unknown)")
        series_list.append(s)

    build_questions_py(series_list, name_map=name_map, out_path=args.out)


if __name__ == "__main__":
    main()
